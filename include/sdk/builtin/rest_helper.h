/**
* SecuRT
* No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
*
* The version of the OpenAPI document: 0.1
*/
/*
 * Helpers.h
 *
 * This is the helper class for models and primitives
 */

#ifndef Helpers_H_
#define Helpers_H_

#include <ctime>
#include <string>
#include <sstream>
#include <vector>
#include <map>

#include "defines.h"

namespace org {
	namespace openapitools {
		namespace server {
			namespace helpers {
				class ValidationException : public std::runtime_error
				{
				public:
					explicit ValidationException(std::string const& what)
						: std::runtime_error(what) {
					}

					~ValidationException() override = default;
				};

				/// <summary>
    /// Validate a string against the full-date definition of RFC 3339, section 5.6.
    /// </summary>
				EXPORT bool validateRfc3339_date(std::string const& str);

				/// <summary>
    /// Validate a string against the date-time definition of RFC 3339, section 5.6.
    /// </summary>
				EXPORT bool validateRfc3339_date_time(std::string const& str);

				namespace sfinae_helpers {
					struct NoType
					{
					};

					template <typename T1, typename T2>
					NoType operator==(T1 const&, T2 const&);

					template <typename T1, typename T2>
					class EqualsOperatorAvailable
					{
					public:
						enum
						{
							value = !std::is_same<decltype(std::declval<T1>() == std::declval<T2>()), NoType>::value
						};
					};
				} // namespace sfinae_helpers


				/// <summary>
    /// Determine if the given vector<T> only has unique elements. T must provide the == operator.
    /// </summary>
				template <typename T>
				EXPORT bool hasOnlyUniqueItems(std::vector<T> const& vec) {
					static_assert(sfinae_helpers::EqualsOperatorAvailable<T, T>::value,
					              "hasOnlyUniqueItems<T> cannot be called, passed template type does not provide == operator.");
					if (vec.size() <= 1)
					{
						return true;
					}
					// Compare every element of vec to every other element of vec.
					// This isn't an elegant way to do this, since it's O(n^2),
					// but it's the best solution working only with the == operator.
					// This could be greatly improved if our models provided a valid hash
					// and/or the < operator
					for (size_t i = 0; i < vec.size() - 1; i++)
					{
						for (size_t j = i + 1; j < vec.size(); j++)
						{
							if (vec[i] == vec[j])
							{
								return false;
							}
						}
					}
					return true;
				}

				EXPORT std::string toStringValue(std::string const& value);
				EXPORT std::string toStringValue(int32_t const value);
				EXPORT std::string toStringValue(int64_t const value);
				EXPORT std::string toStringValue(bool const value);
				EXPORT std::string toStringValue(float const value);
				EXPORT std::string toStringValue(double const value);

				EXPORT bool fromStringValue(std::string const& inStr, std::string& value);
				EXPORT bool fromStringValue(std::string const& inStr, int32_t& value);
				EXPORT bool fromStringValue(std::string const& inStr, int64_t& value);
				EXPORT bool fromStringValue(std::string const& inStr, bool& value);
				EXPORT bool fromStringValue(std::string const& inStr, float& value);
				EXPORT bool fromStringValue(std::string const& inStr, double& value);

				template <typename T>
				EXPORT bool fromStringValue(std::vector<std::string> const& inStr, std::vector<T>& value) {
					try
					{
						for (auto& item : inStr)
						{
							T itemValue;
							if (fromStringValue(item, itemValue))
							{
								value.push_back(itemValue);
							}
						}
					}
					catch (...)
					{
						return false;
					}
					return value.size() > 0;
				}

				template <typename T>
				EXPORT bool fromStringValue(std::string const& inStr, std::vector<T>& value, char separator = ',') {
					std::vector<std::string> inStrings;
					std::istringstream f(inStr);
					std::string s;
					while (std::getline(f, s, separator))
					{
						inStrings.push_back(s);
					}
					return fromStringValue(inStrings, value);
				}
			}
		}
	}
} // namespace org::openapitools::server::helpers

#endif // Helpers_H_
